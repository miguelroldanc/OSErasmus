Here are possible solutions for some of the exercises in the 14th lab:

<! ------------------------------------------------ -------------------------------------------------- ----------------------->

1. Write a C program that, run in the background, periodically displays (e.g., every 20 seconds) the contents of the file
remember.txt (will initially create a file with this name and some content). In addition, whenever the program will receive
the SIGUSR1 signal, will execute the finger -p command, and upon receiving the SIGINT signal the program will end its execution and display
a text with a completion message.
(Note: for periodic display, the SIGALRM signal, generated with the alarm () call that sets a clock alarm, can be processed.)

The solution idea: the 3 signals indicated in the statement must be treated; at execution you will generate these 3 types of signals in the way
next: generate the SIGINT signal by pressing CTRL + C when the program is running in the foreground (or you can generate it
with kill command); you can only generate the SIGUSR1 signal explicitly, with a kill command executed from another shell (or from the same
shell, if you start the program in the background); and the SIGALRM signal will be generated by the program using alarm () calls.
So here is a possible solution:

lab14_ex1.c:
=============

#include <unistd.h>
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <fcntl.h>

void handle_sigint (int nr_sem)
{
    printf ("Process execution completed. \ n");
    exit (0);
}

void handle_sigusr1 (int nr_sem)
{
    system ("finger -p");
}

void handle_sigalrm (int nr_sem)
{
    int fd, cod_r;
    char ch;

    if (-1 == (fd = open ("remember.txt", O_RDONLY)))
    {
perror ("Error opening remembr.txt file");
exit (1);
    }

    printf ("Remember: \ n");
    do{
if (-1 == (cod_r = read (fd, & ch, sizeof (char))))
        {
            perror ("Error reading file");
            exit (2);
        }
if (cod_r == 1) / * if it successfully read a byte, we display it * /
{
printf ("% c", ch);
            fflush (stdout);
        }
    } while (cod_r! = 0); / * until EOF * /
    printf ("\ n");

    close (fd);
}


int main ()
{
    / * first we attach the handlers for the 3 signals we want to process in the program * /
    signal (SIGINT, handle_sigint);
    signal (SIGUSR1, handle_sigusr1);
    signal (SIGALRM, handle_sigalrm);
    
    while (1)
    {
alarm (20); / * set the alarm in 20 seconds * /
        pause (); / * we suspend the execution until the next signal is received * /
    }

    return 0;
}

<! ------------------------------------------------ -------------------------------------------------- ----------------------->

2. [Hi-ho v2, with signals] Rewrite the hi.c and ho.c programs from the [Hi-ho] exercise in the previous lab, using
signals instead of fifo channels to achieve the necessary synchronizations.

The idea of ​​solving: the notifications to be sent between the 2 processes, which were made by sending messages through
2 fifos to the [Hi-ho] exercise from the previous lab will now be transmitted via SIGUSR1 (or SIGUSR2) signals.
In addition, each process must know the PID of the other process in order to send a signal. As such, it must
solved this problem as well, e.g. each process will communicate its own PID to the other process using 2 fifo channels.
As the purpose of this exercise is to learn to use signals, and not fifo communication, we will simplify the solution,
in the sense that the 2 processes will no longer be separated, but related by fork (), one will be the son of the other, and thus each will
knows the other's PID. Next we will focus on the correct use of signals to implement
the synchronization model required in the statement of the problem.

a) Here is a first solution: each process sends the other a SIGUSR1 signal by explicit request with a kill () call, and waits
receiving the signal from the other process with a pause call (), which causes the execution to be suspended until a signal is received:

lab14_ex2a.c:
==============

#include <unistd.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>

#define NR_AFISARI 100 / * how many hi-ho pairs do you want to be displayed * /

void handler_sigusr1 (int nr_sem)
{
    fprintf (stderr, "Debug: process with PID% d received signal. \ n", getpid ());
    / * this is a debugging message; can be "ignored" at execution by redirection:
       UNIX> ./a.out 2> / dev / null
    * /
}

int main ()
{
    int pid, i;

    if (SIG_ERR == signal (SIGUSR1, handler_sigusr1))
    {
perror ("Signal error");
exit (1);
    }
    
    if (-1 == (pid = fork ()))
    {
perror ("Error on fork");
exit (2);
    }

    if (pid! = 0)
    {/ * father: responsible for hi * /
for (i = 0; i <NR_AFISARI; i ++)
{
printf ("hi-"); fflush (stdout); / * HI display * /

kill (pid, SIGUSR1); / * send notification to other process * /

pause (); / * I am waiting for the notification from the other process * /
}
    }
    else
    {/ * son: responsible for ho * *
for (i = 0; i <NR_AFISARI; i ++)
{
pause (); / * I am waiting for the notification from the other process * /

printf ("ho,"); fflush (stdout); / * HO display / /

kill (getppid (), SIGUSR1); / * send notification to other process * /
}
        printf ("\ nEnd. \ n");
    }
    
    return 0;
}

Observation:
Repeating the execution of the program a sufficient number of times, you will notice that sometimes it displays correctly the 100 hi-ho pairs,
and sometimes it crashes before the 100 pairs are finished displaying.
The explanation is as follows: those blocking situations occur when one of the 2 processes receives the corresponding signal.
an iteration of the loop before the pause () call corresponding to that iteration is executed. In other words, when
a signal is delivered to the process before it has started waiting for that signal.
An example of such a situation:
if the HI process runs out of the amount of processor time allocated after executing kill (), but before executing pauses (),
then it will continue with a new quantum for the HO process in which: the signal is delivered to him, he displays his message, he sends
the signal to the HI process and then suspends its execution by pauses (), after which when the HI process receives a new amount of
execution will be delivered the signal, then execute the pause () call and thus suspend its execution, at which point both processes
they are suspended and neither will be able to send a signal to "wake up" the other.


b) The second solution idea: the only efficient way in 100% of the possible situations is to guarantee that a signal
it is not delivered to the process until it has begun waiting for that signal. This can only be achieved through
blocking the reception of the signal (when a signal is generated for that process, it will not be delivered immediately, but will stay in
queue of signals from the system waiting to be delivered, until that process will unblock the reception of that signal).
Specifically, we will block the reception of the SIGUSR1 signal at the beginning of the execution of the HI and HO processes, and then in the loops of the two
processes we will perform the signal waiting by a sigsuspend () call with a parameter that will indicate the signal waiting
SIGUSR1; the correctness of the approached solution is essentially based on the behavior of the sigsuspend () function: it replaces the mask
current of blocked signals with the one received as parameter, then suspend the execution until receiving a signal from the given mask
as a parameter, and finally restores the initial mask of blocked signals.

lab14_ex2b.c:
==============

#include <unistd.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>

#define NR_AFISARI 100

void handler_sigusr1 (int nr_sem)
{
    fprintf (stderr, "Debug: process with PID% d received signal. \ n", getpid ());
    / * this is a debugging message; can be "ignored" at execution by redirection:
       UNIX> ./a.out 2> / dev / null
    * /
}

int main ()
{
    int pid, i;
    sigset_t masca_semnale_usr1_blocat, masca_semnale_usr1_deblocat;

    sigemptyset (& usr1_signal_sign_mask);
    sigaddset (& usr1_signal_sign_mask, SIGUSR1);

    sigfillset (& usr1_sign_mask_block);
    sigdelset (& usr1_sign_sign_mask, unlocked, SIGUSR1);

    if (SIG_ERR == signal (SIGUSR1, handler_sigusr1))
    {
perror ("Signal error");
exit (1);
    }

    if (-1 == sigprocmask (SIG_BLOCK, & usr1_sign_sign_mask, NULL))
    {
perror ("Error in sigprocmask");
exit (2);
    }
    
    if (-1 == (pid = fork ()))
    {
perror ("Error on fork");
exit (3);
    }

    if (pid == 0)
    {/ * son: responsible for hi * /
for (i = 0; i <NR_AFISARI; i ++)
{
printf ("hi-"); fflush (stdout); / * HI display * /

kill (getppid (), SIGUSR1); / * send notification to other process * /

sigsuspend (& usr1_sign_mask_block); / * I am waiting for the notification from the other process * /
}
    }
    else
    {/ * father: responsible for ho * *
for (i = 0; i <NR_AFISARI; i ++)
{
sigsuspend (& usr1_sign_mask_block); / * I am waiting for the notification from the other process * /

printf ("ho,"); fflush (stdout); / * HO display / /

kill (pid, SIGUSR1); / * send notification to other process * /
}
        printf ("\ nEnd. \ n");
    }
    
    return 0;
}

Observation:
As explained above, you can see from the program that the processes blocked the reception of SIGUSR1 signals
throughout the execution time of the display loops, except for the time intervals consumed by sigsuspend () calls
from these loops, intervals in which the reception of a SIGUSR1 signal is allowed, and moreover, it is expected no matter how much
it is needed (i.e. the sigsuspend () call causes the program execution to be suspended until such a signal is received).

<! ------------------------------------------------ -------------------------------------------------- ----------------------->
